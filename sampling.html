<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <!-- ★スマホ対応：これがないと横幅計算が崩れやすい -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>アルゴのサンプリング</title>
  <style>
    body, html {
      margin: 0; padding: 0;
      background: #228B22;
      font-family: sans-serif;
    }

    body {
      padding: 12px;
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    #wrap {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      justify-content: center;
      width: 100%;
      max-width: 1200px;
    }

    canvas {
      border: 2px solid #000;
      background: #228B22;
      width: min(800px, 100%);
      height: auto;
      touch-action: manipulation;
    }

    #panel{
      width: 330px;
      max-width: 100%;
      background: rgba(255,255,255,0.92);
      border: 2px solid #000;
      border-radius: 10px;
      padding: 12px;
      box-sizing: border-box;
      max-height: calc(100vh - 24px);
      overflow-y: auto;
    }
    #panel h2{ margin:0 0 10px; font-size:16px; }

    .topRow{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 13px;
      font-weight: bold;
      gap: 10px;
    }

    .slotBlock{
      border: 1px solid rgba(0,0,0,0.25);
      border-radius: 10px;
      padding: 10px;
      margin: 10px 0;
      background: rgba(255,255,255,0.65);
    }
    .slotTitle{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
      font-weight:bold;
      font-size: 13px;
    }
    .toggle{
      display:flex;
      gap: 8px;
      font-size: 12px;
      font-weight: normal;
      align-items: center;
      white-space: nowrap;
      flex-wrap: wrap;
    }
    .toggle label{
      display:inline-flex;
      gap: 4px;
      align-items:center;
      cursor: pointer;
      user-select: none;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    select{ font-size: 14px; padding: 4px; }

    #errorBox{
      display:none;
      margin-top: 10px;
      padding: 8px;
      border: 2px solid #b00020;
      background: rgba(176,0,32,0.08);
      color: #b00020;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.35;
      white-space: pre-line;
    }

    @media (max-width: 900px) {
      #wrap {
        flex-direction: column;
        align-items: stretch;
      }
      #panel { width: 100%; }
      canvas { width: 100%; }
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <div id="panel">
    <h2>固定する色またはカードを指定</h2>

    <div class="topRow">
      <span>カード枚数</span>
      <select id="countSelect"></select>
    </div>

    <div id="selectors"></div>
    <div id="errorBox"></div>
  </div>
</div>

<script>
/* ===================== デッキ ===================== */
const deck = [];
for (let n = 0; n <= 11; n++) deck.push({ color: 'black', num: n });
for (let n = 0; n <= 11; n++) deck.push({ color: 'white', num: n });

/* ===================== Canvas ===================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const MARGIN = 20;

/* ===================== UI ===================== */
const selectorsDiv = document.getElementById('selectors');
const errorBox = document.getElementById('errorBox');
const countSelect = document.getElementById('countSelect');

/* ===================== 可変状態 ===================== */
let SLOT_COUNT = 4;
let CARD_W = 120;
let CARD_H = 180;
let slots = [];
let settings = [];
// 表示：確定カードは {color,num}、色固定プレビューは {color,num:null}、未確定は null
let cards = [];

/* ===================== ユーティリティ ===================== */
const cardKey = (c) => `${c.color}-${c.num}`;

// 昇順（同数は黒→白）。black < white
function cmpCard(a, b){
  if (a.num !== b.num) return a.num - b.num;
  const ra = (a.color === 'black') ? 0 : 1;
  const rb = (b.color === 'black') ? 0 : 1;
  return ra - rb;
}
const leq = (a,b) => cmpCard(a,b) <= 0;

function showError(msg){
  errorBox.style.display = 'block';
  errorBox.textContent = msg;
}
function clearError(){
  errorBox.style.display = 'none';
  errorBox.textContent = '';
}

function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* ===================== レイアウト ===================== */
function rebuildSlots(){
  const paddingX = 40;
  const availableW = canvas.width - paddingX * 2;
  const idealW = (availableW - (SLOT_COUNT - 1) * MARGIN) / SLOT_COUNT;

  CARD_W = Math.max(70, Math.min(120, Math.floor(idealW)));
  CARD_H = Math.floor(CARD_W * 1.5);

  const totalW = SLOT_COUNT * CARD_W + (SLOT_COUNT - 1) * MARGIN;
  const startX = (canvas.width - totalW) / 2;
  const startY = (canvas.height - CARD_H) / 2;

  slots = [];
  for (let i = 0; i < SLOT_COUNT; i++){
    slots.push({ x: startX + i * (CARD_W + MARGIN), y: startY });
  }
}

/* ===================== 描画 ===================== */
function draw(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < SLOT_COUNT; i++){
    const {x, y} = slots[i];
    const c = cards[i];

    if (c === null){
      // ランダム未確定：グレー、数字なし
      ctx.fillStyle = '#C8C8C8';
      ctx.fillRect(x, y, CARD_W, CARD_H);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, CARD_W, CARD_H);
      continue;
    }

    // 色固定 or 確定カード
    ctx.fillStyle = (c.color === 'black') ? '#000' : '#fff';
    ctx.fillRect(x, y, CARD_W, CARD_H);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4;
    ctx.strokeRect(x, y, CARD_W, CARD_H);

    // num が null のときは数字を表示しない（色固定プレビュー）
    if (c.num === null || c.num === undefined) continue;

    ctx.fillStyle = (c.color === 'black') ? '#fff' : '#000';
    ctx.font = `bold ${Math.floor(CARD_W*0.55)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(c.num), x + CARD_W/2, y + CARD_H/2);
  }
}

/* ===================== 制約の解釈（ランダム / 色固定 / 固定） ===================== */
function getConstraints(){
  // fixedAt[i] = {color,num} | null（固定のみ）
  // colorAt[i] = 'black'|'white'|null（色固定・固定）
  const fixedAt = Array(SLOT_COUNT).fill(null);
  const colorAt = Array(SLOT_COUNT).fill(null);
  const fixedList = [];
  const freePositions = []; // 固定以外（random/color）

  let needBlack = 0; // 色固定スロットの必要数
  let needWhite = 0;

  for (let i = 0; i < SLOT_COUNT; i++){
    const s = settings[i];
    if (s.mode === 'fixed'){
      const c = { color: s.color, num: Number(s.num) };
      fixedAt[i] = c;
      colorAt[i] = s.color;
      fixedList.push(c);
    } else {
      freePositions.push(i);
      if (s.mode === 'color'){
        colorAt[i] = s.color;
        if (s.color === 'black') needBlack++;
        if (s.color === 'white') needWhite++;
      }
    }
  }

  // 固定カード重複チェック（色＋数字）
  const set = new Set(fixedList.map(cardKey));
  if (set.size !== fixedList.length){
    return { ok:false, msg:'エラー：固定カード（色＋数字）が重複しています。' };
  }

  return {
    ok:true,
    fixedAt,
    colorAt,
    fixedList,
    freePositions,
    needBlack,
    needWhite
  };
}

/* ===================== drawn を free slots に当てはめる（昇順＋色制約＋固定境界） ===================== */
function tryPlaceDrawnIntoFreeSlots(fixedAt, colorAt, freePositions, drawn){
  // 右側の「固定カード」境界（固定のみを境界に使う）
  const nextFixed = Array(SLOT_COUNT).fill(null);
  let last = null;
  for (let i = SLOT_COUNT - 1; i >= 0; i--){
    nextFixed[i] = last;
    if (fixedAt[i]) last = fixedAt[i];
  }

  const full = Array(SLOT_COUNT).fill(null);
  for (let i = 0; i < SLOT_COUNT; i++){
    if (fixedAt[i]) full[i] = fixedAt[i];
  }

  const pool = drawn.slice(); // この中からだけ使う（= 先に引いた手札）
  const fp = freePositions.slice().sort((a,b)=>a-b);

  function prevCard(pos){
    for (let i = pos - 1; i >= 0; i--){
      if (full[i]) return full[i];
    }
    return null;
  }

  function dfs(idx){
    if (idx === fp.length) return true;
    const pos = fp[idx];

    const prev = prevCard(pos);
    const rightBound = nextFixed[pos];
    const needColor = colorAt[pos]; // nullなら自由

    const candIdx = [];
    for (let k = 0; k < pool.length; k++){
      const c = pool[k];
      if (needColor && c.color !== needColor) continue;
      if (prev && !leq(prev, c)) continue;
      if (rightBound && !leq(c, rightBound)) continue;
      candIdx.push(k);
    }
    if (candIdx.length === 0) return false;

    shuffleInPlace(candIdx);
    for (const k of candIdx){
      const c = pool[k];
      full[pos] = c;

      const removed = pool.splice(k, 1)[0];
      if (dfs(idx + 1)) return true;

      pool.splice(k, 0, removed);
      full[pos] = null;
    }
    return false;
  }

  const ok = dfs(0);
  if (!ok) return null;

  // 最終チェック（昇順）
  for (let i = 1; i < SLOT_COUNT; i++){
    if (!leq(full[i-1], full[i])) return null;
  }
  return full;
}

/* ===================== 提案方式：先に引く→当てはめられたら採用（色固定も考慮） ===================== */
function buildByResample(){
  const info = getConstraints();
  if (!info.ok) return { ok:false, msg: info.msg };

  const { fixedAt, colorAt, fixedList, freePositions, needBlack, needWhite } = info;

  const needTotal = freePositions.length;
  if (deck.length - fixedList.length < needTotal){
    return { ok:false, msg:'エラー：残りデッキが不足しています。' };
  }

  // 固定カードを除いた残り
  const fixedSet = new Set(fixedList.map(cardKey));
  const baseRemaining = deck.filter(c => !fixedSet.has(cardKey(c)));

  // 色ごとに分ける（色固定の枚数を必ず確保して引く）
  const remBlack = baseRemaining.filter(c => c.color === 'black');
  const remWhite = baseRemaining.filter(c => c.color === 'white');

  if (remBlack.length < needBlack){
    return { ok:false, msg:'エラー：黒カードが不足しています（色固定が多すぎます）。' };
  }
  if (remWhite.length < needWhite){
    return { ok:false, msg:'エラー：白カードが不足しています（色固定が多すぎます）。' };
  }

  const MAX_RESAMPLE = 4000;

  for (let t = 0; t < MAX_RESAMPLE; t++){
    // (A) まず「必要色」を先に引く
    const b = remBlack.slice(); shuffleInPlace(b);
    const w = remWhite.slice(); shuffleInPlace(w);

    const drawn = [];
    const pickedSet = new Set();

    const take = (arr, k) => {
      for (let i = 0; i < k; i++){
        const c = arr[i];
        drawn.push(c);
        pickedSet.add(cardKey(c));
      }
    };

    take(b, needBlack);
    take(w, needWhite);

    // (B) 残りは色自由枠ぶん、残り山から引く（重複しないように）
    const remainNeed = needTotal - drawn.length;
    if (remainNeed < 0) return { ok:false, msg:'内部エラー：必要枚数計算が不正です。' };

    if (remainNeed > 0){
      const rest = baseRemaining.filter(c => !pickedSet.has(cardKey(c)));
      shuffleInPlace(rest);
      for (let i = 0; i < remainNeed; i++){
        drawn.push(rest[i]);
      }
    }

    // (C) この drawn を条件に合うように slots へ当てはめる
    const placed = tryPlaceDrawnIntoFreeSlots(fixedAt, colorAt, freePositions, drawn);
    if (placed) return { ok:true, cards: placed };
  }

  return { ok:false, msg:'エラー：条件を満たす配置が見つかりませんでした。' };
}

/* ===================== プレビュー（固定/色固定だけ表示） ===================== */
function previewFixedOnly(){
  clearError();
  cards = Array(SLOT_COUNT).fill(null);

  for (let i = 0; i < SLOT_COUNT; i++){
    const s = settings[i];
    if (s.mode === 'fixed'){
      cards[i] = { color: s.color, num: Number(s.num) };
    } else if (s.mode === 'color'){
      // 色だけ表示（数字は未確定）
      cards[i] = { color: s.color, num: null };
    }
  }

  // 矛盾がないか軽くテスト（エラーだけ出す）
  const test = buildByResample();
  if (!test.ok) showError(test.msg);

  draw();
}

/* ===================== UI構築 ===================== */
function rebuildSettings(){
  settings = Array.from({length: SLOT_COUNT}, (_, i) => ({
    // mode: 'random' | 'color' | 'fixed'
    mode: 'random',
    color: (i % 2 === 0) ? 'black' : 'white',
    num: i % 12
  }));

  selectorsDiv.innerHTML = '';

  for (let i = 0; i < SLOT_COUNT; i++){
    const block = document.createElement('div');
    block.className = 'slotBlock';

    const numOptions = Array.from({length:12}, (_,n)=>`<option value="${n}">${n}</option>`).join('');

    block.innerHTML = `
      <div class="slotTitle">
        <span>スロット ${i+1}</span>
        <span class="toggle">
          <label><input type="radio" name="mode-${i}" value="random" checked>ランダム</label>
          <label><input type="radio" name="mode-${i}" value="color">色</label>
          <label><input type="radio" name="mode-${i}" value="fixed">カード</label>
        </span>
      </div>
      <div class="row">
        <select class="colorSel" disabled>
          <option value="black">黒</option>
          <option value="white">白</option>
        </select>
        <select class="numSel" disabled>
          ${numOptions}
        </select>
      </div>
    `;

    selectorsDiv.appendChild(block);

    const rbRandom = block.querySelector(`input[value="random"]`);
    const rbColor  = block.querySelector(`input[value="color"]`);
    const rbFixed  = block.querySelector(`input[value="fixed"]`);
    const colorSel = block.querySelector('.colorSel');
    const numSel   = block.querySelector('.numSel');

    colorSel.value = settings[i].color;
    numSel.value   = settings[i].num;

    function syncEnabled(){
      const m = settings[i].mode;
      colorSel.disabled = (m === 'random');
      numSel.disabled   = (m !== 'fixed');
    }

    rbRandom.addEventListener('change', () => {
      settings[i].mode = 'random';
      syncEnabled();
      previewFixedOnly();
    });

    rbColor.addEventListener('change', () => {
      settings[i].mode = 'color';
      syncEnabled();
      previewFixedOnly();
    });

    rbFixed.addEventListener('change', () => {
      settings[i].mode = 'fixed';
      syncEnabled();
      previewFixedOnly();
    });

    colorSel.addEventListener('change', () => {
      settings[i].color = colorSel.value;
      previewFixedOnly();
    });

    numSel.addEventListener('change', () => {
      settings[i].num = Number(numSel.value);
      previewFixedOnly();
    });

    syncEnabled();
  }

  rebuildSlots();
  previewFixedOnly();
}

/* ===================== イベント ===================== */
canvas.addEventListener('click', () => {
  const res = buildByResample(); // ←提案方式を採用
  if (!res.ok){
    showError(res.msg);
    return;
  }
  clearError();
  cards = res.cards; // 色固定のスロットもここで数字が確定（ルール遵守／重複なし）
  draw();
});

/* ===================== 初期化（枚数選択） ===================== */
(function initCountSelect(){
  for (let n = 2; n <= 8; n++){
    const opt = document.createElement('option');
    opt.value = String(n);
    opt.textContent = String(n);
    if (n === SLOT_COUNT) opt.selected = true;
    countSelect.appendChild(opt);
  }

  countSelect.addEventListener('change', () => {
    SLOT_COUNT = Number(countSelect.value);
    rebuildSettings();
  });
})();

rebuildSettings();
</script>
</body>
</html>
