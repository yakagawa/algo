<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <!-- ★スマホ対応：これがないと横幅計算が崩れやすい -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>アルゴのサンプリング</title>
  <style>
    body, html {
      margin: 0; padding: 0;
      background: #228B22;
      font-family: sans-serif;
    }

    body {
      padding: 12px;
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    #wrap {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      justify-content: center;
      width: 100%;
      max-width: 1200px;
    }

    canvas {
      border: 2px solid #000;
      background: #228B22;
      width: min(800px, 100%);
      height: auto;
      touch-action: manipulation;
    }

    #panel{
      width: 330px;
      max-width: 100%;
      background: rgba(255,255,255,0.92);
      border: 2px solid #000;
      border-radius: 10px;
      padding: 12px;
      box-sizing: border-box;
      max-height: calc(100vh - 24px);
      overflow-y: auto;
    }
    #panel h2{ margin:0 0 10px; font-size:16px; }

    .topRow{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 13px;
      font-weight: bold;
      gap: 10px;
    }

    .slotBlock{
      border: 1px solid rgba(0,0,0,0.25);
      border-radius: 10px;
      padding: 10px;
      margin: 10px 0;
      background: rgba(255,255,255,0.65);
    }
    .slotTitle{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 8px;
      font-weight:bold;
      font-size: 13px;
    }
    .toggle{
      display:flex;
      gap: 8px;
      font-size: 12px;
      font-weight: normal;
      align-items: center;
      white-space: nowrap;
      flex-wrap: wrap;
    }
    .toggle label{
      display:inline-flex;
      gap: 4px;
      align-items:center;
      cursor: pointer;
      user-select: none;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    select{ font-size: 14px; padding: 4px; }

    #errorBox{
      display:none;
      margin-top: 10px;
      padding: 8px;
      border: 2px solid #b00020;
      background: rgba(176,0,32,0.08);
      color: #b00020;
      border-radius: 8px;
      font-size: 13px;
      line-height: 1.35;
      white-space: pre-line;
    }

    @media (max-width: 900px) {
      #wrap {
        flex-direction: column;
        align-items: stretch;
      }
      #panel {
        width: 100%;
      }
      canvas {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <div id="panel">
    <h2>固定する色またはカードを指定</h2>

    <div class="topRow">
      <span>カード枚数</span>
      <select id="countSelect"></select>
    </div>

    <div id="selectors"></div>
    <div id="errorBox"></div>
  </div>
</div>

<script>
/* ===================== デッキ ===================== */
const deck = [];
for (let n = 0; n <= 11; n++) deck.push({ color: 'black', num: n });
for (let n = 0; n <= 11; n++) deck.push({ color: 'white', num: n });

/* ===================== Canvas ===================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const MARGIN = 20;

/* ===================== UI ===================== */
const selectorsDiv = document.getElementById('selectors');
const errorBox = document.getElementById('errorBox');
const countSelect = document.getElementById('countSelect');

/* ===================== 可変状態 ===================== */
let SLOT_COUNT = 4;
let CARD_W = 120;
let CARD_H = 180;
let slots = [];
let settings = [];
let cards = []; // 表示：確定カードは {color,num}、色固定プレビューは {color,num:null}、未確定は null

/* ===================== ユーティリティ ===================== */
const cardKey = (c) => `${c.color}-${c.num}`;

// 昇順（同数は黒→白）。black < white
function cmpCard(a, b){
  if (a.num !== b.num) return a.num - b.num;
  const ra = (a.color === 'black') ? 0 : 1;
  const rb = (b.color === 'black') ? 0 : 1;
  return ra - rb;
}
const leq = (a,b) => cmpCard(a,b) <= 0;

function showError(msg){
  errorBox.style.display = 'block';
  errorBox.textContent = msg;
}
function clearError(){
  errorBox.style.display = 'none';
  errorBox.textContent = '';
}

function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* ===================== レイアウト ===================== */
function rebuildSlots(){
  const paddingX = 40;
  const availableW = canvas.width - paddingX * 2;
  const idealW = (availableW - (SLOT_COUNT - 1) * MARGIN) / SLOT_COUNT;

  CARD_W = Math.max(70, Math.min(120, Math.floor(idealW)));
  CARD_H = Math.floor(CARD_W * 1.5);

  const totalW = SLOT_COUNT * CARD_W + (SLOT_COUNT - 1) * MARGIN;
  const startX = (canvas.width - totalW) / 2;
  const startY = (canvas.height - CARD_H) / 2;

  slots = [];
  for (let i = 0; i < SLOT_COUNT; i++){
    slots.push({ x: startX + i * (CARD_W + MARGIN), y: startY });
  }
}

/* ===================== 描画 ===================== */
function draw(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < SLOT_COUNT; i++){
    const {x, y} = slots[i];
    const c = cards[i];

    if (c === null){
      // ランダム未確定：グレー、数字なし
      ctx.fillStyle = '#C8C8C8';
      ctx.fillRect(x, y, CARD_W, CARD_H);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, CARD_W, CARD_H);
      continue;
    }

    // 色固定 or 確定カード
    ctx.fillStyle = (c.color === 'black') ? '#000' : '#fff';
    ctx.fillRect(x, y, CARD_W, CARD_H);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 4;
    ctx.strokeRect(x, y, CARD_W, CARD_H);

    // num が null のときは数字を表示しない（色固定プレビュー）
    if (c.num === null || c.num === undefined) continue;

    ctx.fillStyle = (c.color === 'black') ? '#fff' : '#000';
    ctx.font = `bold ${Math.floor(CARD_W*0.55)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(c.num), x + CARD_W/2, y + CARD_H/2);
  }
}

/* ===================== 制約の解釈（ランダム / 色固定 / 固定） ===================== */
function getConstraints(){
  // fixedAt[i] = {color,num} | null（固定のみ）
  // colorAt[i] = 'black'|'white'|null（色固定・固定）
  const fixedAt = Array(SLOT_COUNT).fill(null);
  const colorAt = Array(SLOT_COUNT).fill(null);
  const fixedList = [];

  for (let i = 0; i < SLOT_COUNT; i++){
    const s = settings[i];
    if (s.mode === 'fixed'){
      const c = { color: s.color, num: Number(s.num) };
      fixedAt[i] = c;
      colorAt[i] = s.color;
      fixedList.push(c);
    } else if (s.mode === 'color'){
      colorAt[i] = s.color;
    }
  }

  // 固定カード重複チェック
  const set = new Set(fixedList.map(cardKey));
  if (set.size !== fixedList.length){
    return { ok:false, msg:'エラー：固定カード（色＋数字）が重複しています。' };
  }

  return { ok:true, fixedAt, colorAt, fixedList };
}

/* ===================== 配置生成（ルール：昇順＆重複なし＆制約を満たす） ===================== */
function buildByDFS(){
  const info = getConstraints();
  if (!info.ok) return { ok:false, msg: info.msg };

  const { fixedAt, colorAt, fixedList } = info;

  if (deck.length < SLOT_COUNT){
    return { ok:false, msg:'エラー：デッキが不足しています。' };
  }

  // 固定カードを除いた残り
  const fixedSet = new Set(fixedList.map(cardKey));
  const poolBase = deck.filter(c => !fixedSet.has(cardKey(c)));

  // 右側に「固定カード」がある場合の上限制約（固定のみ使う）
  const nextExactFixed = Array(SLOT_COUNT).fill(null);
  let last = null;
  for (let i = SLOT_COUNT - 1; i >= 0; i--){
    nextExactFixed[i] = last;
    if (fixedAt[i]) last = fixedAt[i];
  }

  const MAX_TRY = 2000;

  for (let t = 0; t < MAX_TRY; t++){
    const pool = poolBase.slice();
    shuffleInPlace(pool);

    const full = Array(SLOT_COUNT).fill(null);

    // 固定カードを先に埋める
    for (let i = 0; i < SLOT_COUNT; i++){
      if (fixedAt[i]) full[i] = fixedAt[i];
    }

    function prevCard(pos){
      for (let i = pos - 1; i >= 0; i--){
        if (full[i]) return full[i];
      }
      return null;
    }

    function dfs(pos){
      if (pos === SLOT_COUNT) return true;

      // すでに固定なら整合性だけ確認して次へ
      if (fixedAt[pos]){
        const c = fixedAt[pos];
        const p = prevCard(pos);
        if (p && !leq(p, c)) return false;
        const rb = nextExactFixed[pos];
        if (rb && !leq(c, rb)) return false;
        return dfs(pos + 1);
      }

      const p = prevCard(pos);
      const rb = nextExactFixed[pos];
      const needColor = colorAt[pos]; // null なら自由

      // 候補 index を集める
      const cand = [];
      for (let k = 0; k < pool.length; k++){
        const c = pool[k];
        if (needColor && c.color !== needColor) continue;
        if (p && !leq(p, c)) continue;
        if (rb && !leq(c, rb)) continue;
        cand.push(k);
      }
      if (cand.length === 0) return false;

      shuffleInPlace(cand);

      for (const k of cand){
        const c = pool[k];
        full[pos] = c;

        const removed = pool.splice(k, 1)[0];
        if (dfs(pos + 1)) return true;

        pool.splice(k, 0, removed);
        full[pos] = null;
      }
      return false;
    }

    if (dfs(0)){
      // 念のため最終チェック
      for (let i = 1; i < SLOT_COUNT; i++){
        if (!leq(full[i-1], full[i])) return { ok:false, msg:'内部エラー：並び順が崩れました。' };
      }
      return { ok:true, cards: full };
    }
  }

  return { ok:false, msg:'エラー：条件を満たす配置が見つかりませんでした。' };
}

/* ===================== プレビュー（固定/色固定だけ表示） ===================== */
function previewFixedOnly(){
  clearError();
  cards = Array(SLOT_COUNT).fill(null);

  for (let i = 0; i < SLOT_COUNT; i++){
    const s = settings[i];
    if (s.mode === 'fixed'){
      cards[i] = { color: s.color, num: Number(s.num) };
    } else if (s.mode === 'color'){
      // 色だけ表示（数字は未確定）
      cards[i] = { color: s.color, num: null };
    }
  }

  // 矛盾がないか軽くテスト（エラーだけ出す）
  const test = buildByDFS();
  if (!test.ok) showError(test.msg);

  draw();
}

/* ===================== UI構築 ===================== */
function rebuildSettings(){
  settings = Array.from({length: SLOT_COUNT}, (_, i) => ({
    // mode: 'random' | 'color' | 'fixed'
    mode: 'random',
    color: (i % 2 === 0) ? 'black' : 'white',
    num: i % 12
  }));

  selectorsDiv.innerHTML = '';

  for (let i = 0; i < SLOT_COUNT; i++){
    const block = document.createElement('div');
    block.className = 'slotBlock';

    const numOptions = Array.from({length:12}, (_,n)=>`<option value="${n}">${n}</option>`).join('');

    block.innerHTML = `
      <div class="slotTitle">
        <span>スロット ${i+1}</span>
        <span class="toggle">
          <label><input type="radio" name="mode-${i}" value="random" checked>ランダム</label>
          <label><input type="radio" name="mode-${i}" value="color">色</label>
          <label><input type="radio" name="mode-${i}" value="fixed">カード</label>
        </span>
      </div>
      <div class="row">
        <select class="colorSel" disabled>
          <option value="black">黒</option>
          <option value="white">白</option>
        </select>
        <select class="numSel" disabled>
          ${numOptions}
        </select>
      </div>
    `;

    selectorsDiv.appendChild(block);

    const rbRandom = block.querySelector(`input[value="random"]`);
    const rbColor  = block.querySelector(`input[value="color"]`);
    const rbFixed  = block.querySelector(`input[value="fixed"]`);
    const colorSel = block.querySelector('.colorSel');
    const numSel   = block.querySelector('.numSel');

    colorSel.value = settings[i].color;
    numSel.value   = settings[i].num;

    function syncEnabled(){
      const m = settings[i].mode;
      colorSel.disabled = (m === 'random');
      numSel.disabled   = (m !== 'fixed');
    }

    rbRandom.addEventListener('change', () => {
      settings[i].mode = 'random';
      syncEnabled();
      previewFixedOnly();
    });

    rbColor.addEventListener('change', () => {
      settings[i].mode = 'color';
      syncEnabled();
      previewFixedOnly();
    });

    rbFixed.addEventListener('change', () => {
      settings[i].mode = 'fixed';
      syncEnabled();
      previewFixedOnly();
    });

    colorSel.addEventListener('change', () => {
      settings[i].color = colorSel.value;
      previewFixedOnly();
    });

    numSel.addEventListener('change', () => {
      settings[i].num = Number(numSel.value);
      previewFixedOnly();
    });

    syncEnabled();
  }

  rebuildSlots();
  previewFixedOnly();
}

/* ===================== イベント ===================== */
canvas.addEventListener('click', () => {
  const res = buildByDFS();
  if (!res.ok){
    showError(res.msg);
    return;
  }
  clearError();
  cards = res.cards; // 色固定のスロットもここで数字が決まる（ルールに従う／重複なし）
  draw();
});

/* ===================== 初期化（枚数選択） ===================== */
(function initCountSelect(){
  for (let n = 2; n <= 8; n++){
    const opt = document.createElement('option');
    opt.value = String(n);
    opt.textContent = String(n);
    if (n === SLOT_COUNT) opt.selected = true;
    countSelect.appendChild(opt);
  }

  countSelect.addEventListener('change', () => {
    SLOT_COUNT = Number(countSelect.value);
    rebuildSettings();
  });
})();

rebuildSettings();
</script>
</body>
</html>
